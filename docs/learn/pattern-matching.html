<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Pattern matching</title>
  <meta name="title" content="Epos Programming Language Docs — Pattern matching">
  <meta name="description" content="Pattern matching" />

  <!-- Code highlighting -->
  <link rel="stylesheet" href="assets/highlight.js/highlight.min.css">
  <link rel="stylesheet" href="assets/highlight.js/rose-pine-moon.css">
  <script src="assets/highlight.js/highlight.min.js"></script>
  <script src="assets/highlight.js/elixir.min.js"></script>
  <script>hljs.highlightAll();</script>

  <!-- Font preloads -->
  <link rel="preload" href="assets/fonts/junicode/Junicode.ttf" as="font" type="font/ttf" crossorigin />
  <link rel="preload" href="assets/fonts/junicode/Junicode-Bold.ttf" as="font" type="font/ttf" crossorigin />
  <link rel="preload" href="assets/fonts/junicode/Junicode-BoldItalic.ttf" as="font" type="font/ttf" crossorigin />
  <link rel="preload" href="assets/fonts/junicode/Junicode-Italic.ttf" as="font" type="font/ttf" crossorigin />

  <link href="style.css?v=5" rel="stylesheet">
  <style>
    code.elixir {
      @apply language-elixir;
    }
    code.bash {
      @apply language-bash;
    }
  </style>
</head>
<body>
  <main>
    <div>
      <p>
        This page is available as PDF <a href="/learn/pattern-matching.pdf">here</a>.
      </p>
    </div>
    <h1>Pattern Matching</h1>
<p>Pattern matching in Epos replaces traditional if-else statements and
provides powerful control flow based on value structure.</p>
<h2>Basic Match Expressions</h2>
<p>The fundamental syntax uses <code>match ... then ... end</code>:</p>
<pre class="epos"><code>number: int = 42
message: string = match number then
    0 =&gt; &quot;zero&quot;
    1 =&gt; &quot;one&quot;
    42 =&gt; &quot;the answer&quot;
    _ =&gt; &quot;something else&quot;
end
</code></pre>
<h2>Multiple Value Matching</h2>
<p>Match against multiple possible values:</p>
<pre class="epos"><code>day: int = 3
day-type: string = match day then
    1, 2, 3, 4, 5 =&gt; &quot;weekday&quot;
    6, 7 =&gt; &quot;weekend&quot;
    _ =&gt; &quot;invalid day&quot;
end
</code></pre>
<h2>Boolean Matching</h2>
<p>Pattern match on boolean conditions:</p>
<pre class="epos"><code>age: int = 20
status: string = match age &gt;= 18 then
    true =&gt; &quot;adult&quot;
    false =&gt; &quot;minor&quot;
end

# More complex boolean matching
score: int = 85
grade: string = match score then
    _ when score &gt;= 90 =&gt; &quot;A&quot;
    _ when score &gt;= 80 =&gt; &quot;B&quot;
    _ when score &gt;= 70 =&gt; &quot;C&quot;
    _ =&gt; &quot;F&quot;
end
</code></pre>
<h2>List Pattern Matching</h2>
<p>Match on list structure and contents:</p>
<pre class="epos"><code>numbers: list(int) = {1, 2, 3}
empty: list(int) = {}

result: string = match numbers then
    empty =&gt; &quot;empty list&quot;
    {1} =&gt; &quot;just one&quot;
    {1, 2} =&gt; &quot;two elements starting with 1&quot;
    _ =&gt; &quot;something else&quot;
end

# Pattern match with list length
fn describe-list(items: list(t)): string
    match len(items) then
        0 =&gt; &quot;empty&quot;
        1 =&gt; &quot;single item&quot;
        _ =&gt; &quot;multiple items&quot;
    end
end
</code></pre>
<h2>Using Match in Control Flow</h2>
<p>Since Epos doesn’t have traditional loops, use pattern matching with
recursion:</p>
<pre class="epos"><code>fn countdown(n: int)
    print(n)
    match n &lt;= 0 then
        true =&gt; print(&quot;Done!&quot;)
        false =&gt; countdown(n - 1)
    end
end

fn process-list(items: list(string), index: int = 0)
    match index &lt; len(items) then
        true =&gt; {
            print(elem(items, index))
            process-list(items, index + 1)
        }
        false =&gt; print(&quot;All done&quot;)
    end
end
</code></pre>
<h2>Record Pattern Matching</h2>
<p>Match on record structures and fields:</p>
<pre class="epos"><code>record Status
    code: int
    message: string
end

fn handle-response(status: Status): string
    match status.code then
        200 =&gt; &quot;Success: #{status.message}&quot;
        404 =&gt; &quot;Not Found&quot;
        500 =&gt; &quot;Server Error: #{status.message}&quot;
        _ =&gt; &quot;Unknown status: #{status.code}&quot;
    end
end

response: Status = @{
    code =&gt; 200,
    message =&gt; &quot;OK&quot;
}
result := handle-response(response)
</code></pre>
<h2>Nested Pattern Matching</h2>
<p>Pattern matching can be nested for complex logic:</p>
<pre class="epos"><code>record User
    name: string
    age: int
    is-admin: bool
end

fn check-access(user: User): string
    match user.is-admin then
        true =&gt; &quot;Full access granted&quot;
        false =&gt; match user.age &gt;= 18 then
            true =&gt; &quot;Limited access granted&quot;
            false =&gt; &quot;Access denied&quot;
        end
    end
end
</code></pre>
<h2>Pattern Matching with Functions</h2>
<p>Use pattern matching to create different behaviors:</p>
<pre class="epos"><code>fn fibonacci(n: int): int
    match n then
        0 =&gt; 0
        1 =&gt; 1
        _ =&gt; fibonacci(n - 1) + fibonacci(n - 2)
    end
end

fn factorial(n: int): int
    match n &lt;= 1 then
        true =&gt; 1
        false =&gt; n * factorial(n - 1)
    end
end
</code></pre>
<h2>Guards in Pattern Matching</h2>
<p>Use when clauses for additional conditions:</p>
<pre class="epos"><code>fn categorize-number(n: int): string
    match n then
        _ when n &lt; 0 =&gt; &quot;negative&quot;
        0 =&gt; &quot;zero&quot;
        _ when n % 2 == 0 =&gt; &quot;positive even&quot;
        _ when n % 2 == 1 =&gt; &quot;positive odd&quot;
        _ =&gt; &quot;unknown&quot;
    end
end
</code></pre>
<h2>Expression-Based Control</h2>
<p>Since match is an expression, it can be used anywhere a value is
expected:</p>
<pre class="epos"><code># In variable assignment
tax-rate: float = match income then
    _ when income &lt; 10000 =&gt; 0.0
    _ when income &lt; 50000 =&gt; 0.15
    _ =&gt; 0.25
end

# In function arguments
print(match weather then
    &quot;sunny&quot; =&gt; &quot;Wear sunglasses!&quot;
    &quot;rainy&quot; =&gt; &quot;Bring an umbrella!&quot;
    _ =&gt; &quot;Have a nice day!&quot;
end)

# As return values
fn get-discount(customer-type: string): float
    match customer-type then
        &quot;premium&quot; =&gt; 0.20
        &quot;regular&quot; =&gt; 0.10
        &quot;new&quot; =&gt; 0.05
        _ =&gt; 0.0
    end
end
</code></pre>
<p>Pattern matching is the primary control flow mechanism in Epos,
replacing traditional if-else statements and loops with more expressive
and functional constructs.</p>

  </main>
</body>
</html>